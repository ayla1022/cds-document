---
title: 事务处理
date: 2022-01-13 09:33:11
permalink: /pages/477070/
article: true
---

## 场景介绍

云数据库Redis支持事务（transaction）机制。Redis事务时一组命令的集合，事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务属于原子操作，即事务中的命令要么全部被执行，要么全部都不执行。

Redis事务命令包括：`MULTI`，`EXEC`，`DISCARD`，`WATCH`，`UNWATCH`。

>  注意：
>
> Redis中定义的事务，并不是关系数据库中严格意义上的事务。当Redis事务中的某个操作执行失败，或者用DISCARD取消事务时候，Redis不会执行事务回滚。

## 代码示例

- 两个client操作相同的key

```java
import java.util.List;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.Transaction;
public class RedisTranscationTest {
    static final String host = "10.XX.XX.13";
    static final int port = 9736;
    static final String password = "password";
    //**注意这两个key的内容是相同的
    static String client1_key = "Redis-Transcation-1";
    static String client2_key = "Redis-Transcation-1";
    public static void main(String[] args) {
        Jedis jedis = new Jedis(host, port);
        // Redis的实例密码
        String authString = jedis.auth(password);//password
        if (!authString.equals("OK")) {
            System.err.println("认证失败: " + authString);
            jedis.close();
            return;
        }
        jedis.set(client1_key, "0");
        // 启动另一个thread，模拟另外的client
        new RedisTranscationTest().new OtherRedisClient().start();
        Thread.sleep(500);
        Transaction tx = jedis.multi();//开始事务
        // 以下操作会集中提交服务器端处理，作为“原子操作”
        tx.incr(client1_key);
        tx.incr(client1_key);
        Thread.sleep(400);//此处Thread的暂停对事务中前后连续的操作并无影响，其他Thread的操作也无法执行
        tx.incr(client1_key);
        Thread.sleep(300);//此处Thread的暂停对事务中前后连续的操作并无影响，其他Thread的操作也无法执行
        tx.incr(client1_key);
        Thread.sleep(200);//此处Thread的暂停对事务中前后连续的操作并无影响，其他Thread的操作也无法执行
        tx.incr(client1_key);
        List<Object> result = tx.exec();//提交执行
        // 解析并打印出结果
        for(Object rt : result){
            System.out.println("Client 1 > 事务中> "+rt.toString());
        }
        jedis.close();
    }
    class OtherRedisClient extends Thread{
        @Override
        public void run() {
            Jedis jedis = new Jedis(host, port);
            // Redis的实例密码
            String authString = jedis.auth(password);// password
            if (!authString.equals("OK")) {
                System.err.println("AUTH Failed: " + authString);
                jedis.close();
                return;
            }
            jedis.set(client2_key, "100");
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Client 2 > "+jedis.incr(client2_key));
            }
            jedis.close();
        }
    }
}
```

在输入了正确的云数据库Redis版实例访问地址和密码之后，运行以上Java程序，输出结果如下：

```
Client 2 > 101
Client 2 > 102
Client 2 > 103
Client 2 > 104
Client 1 > 事务中> 105
Client 1 > 事务中> 106
Client 1 > 事务中> 107
Client 1 > 事务中> 108
Client 1 > 事务中> 109
Client 2 > 110
Client 2 > 111
Client 2 > 112
Client 2 > 113
Client 2 > 114
Client 2 > 115
```

您可以看到不同线程中的两个client在操作同一个key，但是当client1利用事务机制来操作这个key时，client2被阻塞不得不等待client1事务中的操作完全执行完毕。

- 两个client操作不同的key

对以上的代码稍作改动，使得两个client操作不同key，其余部分保持不变。

```java
import java.util.List;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.Transaction;
public class RedisTranscationTest {
    static final String host = "10.XX.XX.13";
    static final int port = 9736;
    static final String password = "password";
    //**注意这两个key的内容是不同的
    static String client1_key = "Redis-Transcation-1";
    static String client2_key = "Redis-Transcation-2";
    public static void main(String[] args) {
        Jedis jedis = new Jedis(host, port);
        // Redis的实例密码
        String authString = jedis.auth(password);//password
        if (!authString.equals("OK")) {
            System.err.println("认证失败: " + authString);
            jedis.close();
            return;
        }
        jedis.set(client1_key, "0");
        // 启动另一个thread，模拟另外的client
        new RedisTranscationTest().new OtherRedisClient().start();
        Thread.sleep(500);
        Transaction tx = jedis.multi();//开始事务
        // 以下操作会集中提交服务器端处理，作为“原子操作”
        tx.incr(client1_key);
        tx.incr(client1_key);
        Thread.sleep(400);//此处Thread的暂停对事务中前后连续的操作并无影响，其他Thread的操作也无法执行
        tx.incr(client1_key);
        Thread.sleep(300);//此处Thread的暂停对事务中前后连续的操作并无影响，其他Thread的操作也无法执行
        tx.incr(client1_key);
        Thread.sleep(200);//此处Thread的暂停对事务中前后连续的操作并无影响，其他Thread的操作也无法执行
        tx.incr(client1_key);
        List<Object> result = tx.exec();//提交执行
        // 解析并打印出结果
        for(Object rt : result){
            System.out.println("Client 1 > 事务中> "+rt.toString());
        }
        jedis.close();
    }
    class OtherRedisClient extends Thread{
        @Override
        public void run() {
            Jedis jedis = new Jedis(host, port);
            // Redis的实例密码
            String authString = jedis.auth(password);// password
            if (!authString.equals("OK")) {
                System.err.println("AUTH Failed: " + authString);
                jedis.close();
                return;
            }
            jedis.set(client2_key, "100");
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Client 2 > "+jedis.incr(client2_key));
            }
            jedis.close();
        }
    }
}
```

运行修改后的此Java程序，输出结果如下：

```
Client 2 > 101
Client 2 > 102
Client 2 > 103
Client 2 > 104
Client 1 > 事务中> 1
Client 1 > 事务中> 2
Client 1 > 事务中> 3
Client 1 > 事务中> 4
Client 1 > 事务中> 5
Client 2 > 105
Client 2 > 106
Client 2 > 107
Client 2 > 108
Client 2 > 109
Client 2 > 110
```

您从中可以看到client1和 client2在两个不同的Thread中，client1所提交的事务操作都是集中顺序执行的，在此期间尽管client2是对另外一个key进行操作，它的命令操作也都被阻塞等待，直至client1事务中的全部操作执行完毕。